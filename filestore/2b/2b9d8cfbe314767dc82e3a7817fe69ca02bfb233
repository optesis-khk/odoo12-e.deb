import { INIT_ENDED, SET_SESSION_DATA, SET_USER_RIGHT, LOGOUT,
  CREATE_BLANK_AXIOS_INSTANCE, CREATE_AXIOS_INSTANCE, RESET_AXIOS_INSTANCE,
  REGISTER_REQUEST, REGISTER_FAILURE, REGISTER_SUCCESS,
   GET_NOTIFICATIONS, GET_NOTIFICATIONS_ALL, UPDATE_NOTIFICATIONS_ALL, UPDATE_PUB_LIST } from '../actions/user';


const initialState = {
  initEnded: false,
  status: null,
  error: null,
  next: null,
  roles:{},
  is_admin:false,
  hasMoreItems: true,
  listPub:[],
  blankAxiosInstance: {},
  axiosInstance: {},
  userId: null,
  profilePictureUrl: '',
  first_name:'',
  last_name:'',
  adminGroups: [],
   notifications: {
    list: [],
    count: 0,
  },
  notificationsAll: {
    list: [],
    count: 0,
    next: null,
    hasMoreItems: true,
  },
  filters:{
    filter_fields:[],
    filter_fields_error:null,
    filter_fields_spinner:false,
  }
}

// Possible status :
// - registering
// - validating_account
// - authenticated
// - logout

// Possible acccount types :
// - default
// - ACCOUNT_TYPE_RECRUITER

// There are two reducers for now because it wil be easier to merge with other code
export function user(state = initialState, action){

  switch(action.type) {
    case 'GET_FILTER_ITEMS':
    return {...state,filters:{...state.filters, filter_fields:action.payload.fields}}
 
  case 'GET_FILTER_ITEMS_FAILURE':
    return {...state,filters:{...state.filters, filter_fields:[], filter_fields_error:action.payload.error}}

 case 'SET_FILTER_ITEMS_EMPTY':
    return {...state,filters:{...state.filters, filter_fields:[], filter_fields_error:null}}
    
    case INIT_ENDED:
      return {...state, initEnded: true}

    case REGISTER_REQUEST:
      return {...state, status: 'registering', error: null}

    case REGISTER_SUCCESS:
      return {...state, status: 'validating_account', error: null}

    case REGISTER_FAILURE:
      return {...state, status: 'registering', error: action.payload.error || action.payload.message}

    case LOGOUT:
      return {...state, userId: null, status: 'logout', error: null}

  case UPDATE_PUB_LIST:
      if(action.payload.next) {
        return {...state, listPub: state.listPub.concat(action.payload.results), next: action.payload.next, hasMoreItems: true}
      } else {
        return {...state, listPub: state.listPub.concat(action.payload.results), next: null, hasMoreItems: false}
      }
   case 'SET_ROLES':
   return {...state,roles:action.payload,is_admin:action.payload.right.is_owner}

    case SET_SESSION_DATA:
     const groups = action.adminRoles.filter(obj => obj.table_type === 4);
      return {
          ...state,
          status: 'authenticated',
          error: null,
          userId: action.userId,
          profilePictureUrl: action.picture,
          first_name:action.first_name,
          last_name:action.last_name,
          adminGroups: groups,
        }

    case CREATE_BLANK_AXIOS_INSTANCE:
      return {...state, blankAxiosInstance: action.payload}

    case CREATE_AXIOS_INSTANCE:
      return {...state, axiosInstance: action.payload}

    case RESET_AXIOS_INSTANCE:
      return {...state, axiosInstance: {}}



 case GET_NOTIFICATIONS:
      return {...state, notifications: {...state.notifications, list: action.payload.results, count: action.payload.count}}

    case GET_NOTIFICATIONS_ALL:
      if(action.payload.next) {
        return {
          ...state,
          notificationsAll: {
            ...state.notificationsAll,
            list: action.payload.results,
            count: action.payload.count,
            next: action.payload.next,
            hasMoreItems: true
          }
        }
      } else {
        return {
          ...state,
          notificationsAll: {
            ...state.notificationsAll,
            list: action.payload.results,
            count: action.payload.count,
            next: null,
            hasMoreItems: false
          }
        }
      }

    case UPDATE_NOTIFICATIONS_ALL:
      if(action.payload.next) {
        return {
          ...state,
          notificationsAll: {
            ...state.notificationsAll,
            list: state.notificationsAll.list.concat(action.payload.results),
            count: action.payload.count,
            next: action.payload.next,
            hasMoreItems: true
          }
        }

      } else {
        return {
          ...state,
          notificationsAll: {
            ...state.notificationsAll,
            list: state.notificationsAll.list.concat(action.payload.results),
            count: action.payload.count,
            next: null,
            hasMoreItems: false
          }
        }
      }

    default:
      return state;
  }
}